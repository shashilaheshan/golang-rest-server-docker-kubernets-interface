
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>mocks: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">books-api/t/mocks/post_repo_interface.go (61.8%)</option>
				
				<option value="file1">books-api/t/mongo_init.go (0.0%)</option>
				
				<option value="file2">books-api/t/post_repo.go (0.0%)</option>
				
				<option value="file3">books-api/t/t.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by mockery v2.52.1. DO NOT EDIT.

package mocks

import (
        models "books-api/t/models"

        mock "github.com/stretchr/testify/mock"
)

// PostRepoInterface is an autogenerated mock type for the PostRepoInterface type
type PostRepoInterface struct {
        mock.Mock
}

// AddPost provides a mock function with given fields: post
func (_m *PostRepoInterface) AddPost(post *models.Post) (bool, error) <span class="cov8" title="1">{
        ret := _m.Called(post)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for AddPost")</span>
        }

        <span class="cov8" title="1">var r0 bool
        var r1 error
        if rf, ok := ret.Get(0).(func(*models.Post) (bool, error)); ok </span><span class="cov0" title="0">{
                return rf(post)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(*models.Post) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(post)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(*models.Post) error); ok </span><span class="cov0" title="0">{
                r1 = rf(post)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// GetPosts provides a mock function with no fields
func (_m *PostRepoInterface) GetPosts() (*[]models.Post, error) <span class="cov8" title="1">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetPosts")</span>
        }

        <span class="cov8" title="1">var r0 *[]models.Post
        var r1 error
        if rf, ok := ret.Get(0).(func() (*[]models.Post, error)); ok </span><span class="cov0" title="0">{
                return rf()
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func() *[]models.Post); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*[]models.Post)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func() error); ok </span><span class="cov0" title="0">{
                r1 = rf()
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// NewPostRepoInterface creates a new instance of PostRepoInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPostRepoInterface(t interface {
        mock.TestingT
        Cleanup(func())
}) *PostRepoInterface <span class="cov0" title="0">{
        mock := &amp;PostRepoInterface{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "time"

        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

// ConnectMongoDB connects to MongoDB and returns a client instance
func ConnectMongoDB() (*mongo.Client, error) <span class="cov0" title="0">{
        mongoURI := "mongodb://localhost:27017"

        clientOptions := options.Client().
                ApplyURI(mongoURI).
                SetConnectTimeout(10 * time.Second)

        client, err := mongo.Connect(context.Background(), clientOptions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error connecting to MongoDB: %w", err)
        }</span>

        // Ping to verify connection
        <span class="cov0" title="0">err = client.Ping(context.Background(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error pinging MongoDB: %w", err)
        }</span>

        <span class="cov0" title="0">log.Println("âœ… Connected to MongoDB")
        return client, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "books-api/t/models"
        "context"
        "log"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type PostRepo struct {
        client      string
        mongoClient *mongo.Client
        logger      Logger
}

func NewPost(client string, mongo *mongo.Client, logger Logger) PostRepoInterface <span class="cov0" title="0">{
        return &amp;PostRepo{client: client, mongoClient: mongo, logger: logger}
}</span>

func (p *PostRepo) GetPosts() (*[]models.Post, error) <span class="cov0" title="0">{
        collection := p.mongoClient.Database(DB).Collection(BOOKS_COLLECTION)

        filter := bson.M{}

        options := options.Find()

        cursor, err := collection.Find(context.Background(), filter, options)

        if err != nil </span><span class="cov0" title="0">{
                p.logger.LogMessage(err.Error())

                return nil, err
        }</span>

        <span class="cov0" title="0">defer cursor.Close(context.Background())

        var posts []models.Post

        for cursor.Next(context.Background()) </span><span class="cov0" title="0">{
                var post models.Post

                if err := cursor.Decode(&amp;post); err != nil </span><span class="cov0" title="0">{
                        p.logger.LogMessage(err.Error())
                        continue</span>
                }

                <span class="cov0" title="0">posts = append(posts, post)</span>
        }
        <span class="cov0" title="0">if err := cursor.Err(); err != nil </span><span class="cov0" title="0">{
                p.logger.LogMessage(err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;posts, nil</span>

}

func (p *PostRepo) AddPost(post *models.Post) (bool, error) <span class="cov0" title="0">{
        collction := p.mongoClient.Database(DB).Collection(BOOKS_COLLECTION)

        postDoc := bson.M{
                "name":   post.Name,
                "author": post.Author,
                "client": post.Client,
        }
        collction.InsertOne(context.Background(), postDoc)

        return true, nil
}</span>

type Logger struct {
}

func NewLogger() *Logger <span class="cov0" title="0">{
        return &amp;Logger{}
}</span>

func (l *Logger) LogMessage(message string) <span class="cov0" title="0">{
        log.Println(message)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "books-api/t/models"
        "encoding/json"
        "fmt"
        "net/http"
)

func GetPosts(res http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        logger := NewLogger()

        client, err := ConnectMongoDB()

        if err != nil </span><span class="cov0" title="0">{
                logger.LogMessage(err.Error())
        }</span>
        <span class="cov0" title="0">postRepo := NewPost("google.com", client, *logger)

        posts, err := postRepo.GetPosts()

        if err != nil </span><span class="cov0" title="0">{
                logger.LogMessage(err.Error())
        }</span>

        <span class="cov0" title="0">res.Header().Set("Content-Type", "application/json")
        json.NewEncoder(res).Encode(posts)</span>
}

func AddPost(res http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{

        fmt.Print(req.Method)
        if req.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(res, "method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">var post models.Post

        err := json.NewDecoder(req.Body).Decode(&amp;post)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(res, "Error on message payload", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">logger := NewLogger()

        client, err := ConnectMongoDB()

        if err != nil </span><span class="cov0" title="0">{
                logger.LogMessage(err.Error())
        }</span>
        <span class="cov0" title="0">postRepo := NewPost("google.com", client, *logger)

        success, err := postRepo.AddPost(&amp;post)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(res, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">if success </span><span class="cov0" title="0">{
                // Send response
                res.WriteHeader(http.StatusCreated)
                response := map[string]interface{}{
                        "message": "Post created successfully",
                }
                json.NewEncoder(res).Encode(response)
        }</span>

}
func main() <span class="cov0" title="0">{
        port := ":8787"
        http.HandleFunc("/posts", GetPosts)
        http.HandleFunc("/addpost", AddPost)
        http.ListenAndServe(port, nil)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
